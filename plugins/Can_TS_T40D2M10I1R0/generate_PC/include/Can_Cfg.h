/**
*   @file    Can_Cfg.h
*   @version 1.0.1
*
*   @brief   AUTOSAR Can - module interface
*   @details Configuration settings generated by user settings.
*
*   @addtogroup CAN_DRIVER
*   @{
*/
/*==================================================================================================
*   Project              : AUTOSAR 4.2 MCAL
*   Platform             : ARM
*   Peripheral           : FLEXCAN
*   Dependencies         : 
*
*   Autosar Version      : 4.2.2
*   Autosar Revision     : ASR_REL_4_2_REV_0002
*   Autosar Conf.Variant :
*   SW Version           : 1.0.1
*   Build Version        : S32K14x_MCAL_1_0_1_RTM_ASR_REL_4_2_REV_0002_20180713
*
*   (c) Copyright 2006-2016 Freescale Semiconductor, Inc. 
*       Copyright 2017-2018 NXP
*   All Rights Reserved.
==================================================================================================*/
/*==================================================================================================
==================================================================================================*/
/*
@brief   (CAN023) The consistency of the configuration must be checked by the configuration tool(s).
@brief   (CAN022) The code configurator of the Can module is CAN controller specific.
         If the CAN controller is sited on-chip, the code generation tool for the Can module is Controller specific.
         If the CAN controller is an external device the generation tool must not be Controller specific.
@brief   (CAN024) The valid values that can be configured are hardware dependent.
         Therefore the rules and constraints can't be given in the standard.
         The configuration tool is responsible to do a static configuration checking, also regarding dependencies between modules (i.e. Port driver, MCU driver etc.)
*/
/*
* @file    Can_Cfg.h
*/

#ifndef CAN_CFG_H
#define CAN_CFG_H

#ifdef __cplusplus
extern "C"{
#endif

/**
* @page misra_violations MISRA-C:2004 violations
*
* @section [global]
* Violates MISRA 2004 Required Rule 5.1, Identifiers (internal and external) shall not rely 
* on the significance of more than 31 characters. The used compilers use more than 31 chars for
* identifiers.
*
* @section [global]
* Violates MISRA 2004 Required Rule 1.4, The compiler/linker shall be checked to ensure that 31 character
* signifiance and case sensitivity are supported for external identifiers.
*
* @section Can_Cfg_h_REF_1
* Violates MISRA 2004 Required Rule 19.15, Repeated include file MemMap.h
* There are different kinds of execution code sections.
*
* @section Can_Cfg_h_REF_2
* Violates MISRA 2004 Advisory Rule 19.7, Function-like macro defined
* This violation is due to function like macros defined for pooling operations.
* Function like macros are used to reduce code complexity.
*
* @section Can_Cfg_h_REF_3
* Violates MISRA 2004 Required Rule 19.4 , The C macro expand to a variable declaration statement or 
* to a function call statement. This C macros is needed in order to have a better mentenability of the code.
*
* @section Can_Cfg_h_REF_4
* Violates MISRA 2004 Required Rule 8.7, Global variables containing the generated configuration
* shall be defined in a separate source file and can't be defined inside a function although it is accessed
* by a single function.
*
*/
/*==================================================================================================
*                                        INCLUDE FILES
* 1) system and project includes
* 2) needed interfaces from external units
* 3) internal and external interfaces from this unit
==================================================================================================*/
/* @violates @ref Can_Cfg_h_REF_1 Violates MISRA 2004 Required Rule 19.15, Repeated include file MemMap.h*/
#include "Std_Types.h"
#include "Soc_Ips.h"

[!AUTOSPACING!]
[!NOCODE!][!//
[!INCLUDE "Can_VersionCheck_Inc.m"!][!//
[!ENDNOCODE!][!//

/*==================================================================================================
*                              SOURCE FILE VERSION INFORMATION
==================================================================================================*/
/*
* @file           Can_Cfg.h
*/
#define CAN_VENDOR_ID_CFG                       43
#define CAN_MODULE_ID_CFG                       80
#define CAN_AR_RELEASE_MAJOR_VERSION_CFG_H      4
#define CAN_AR_RELEASE_MINOR_VERSION_CFG_H      2
#define CAN_AR_RELEASE_REVISION_VERSION_CFG_H   2
#define CAN_SW_MAJOR_VERSION_CFG_H              1
#define CAN_SW_MINOR_VERSION_CFG_H              0
#define CAN_SW_PATCH_VERSION_CFG_H              1

#ifndef DISABLE_MCAL_INTERMODULE_ASR_CHECK
    /* Check if header file and Std_Types.h file are of the same Autosar version */
    #if ((CAN_AR_RELEASE_MAJOR_VERSION_CFG_H != STD_AR_RELEASE_MAJOR_VERSION) || \
         (CAN_AR_RELEASE_MINOR_VERSION_CFG_H != STD_AR_RELEASE_MINOR_VERSION)    \
        )
        #error "AutoSar Version Numbers of Can_Cfg.h and Std_Types.h are different"
    #endif

#endif


/*==================================================================================================
*                                          CONSTANTS
==================================================================================================*/
[!INDENT "0"!]

/**
* @brief          Support for User Mode feature.
* @details        This parameter is enabled only in order to support the write access to some registers are protected in user mode.
*/
[!IF "(CanGeneral/CanEnableUserModeSupport = 'true') and (ecu:get('Can.CanConfig.SupvAvailable') = 'STD_ON')"!]
    #define CAN_ENABLE_USER_MODE_SUPPORT (STD_ON)
[!ELSE!]
    #define CAN_ENABLE_USER_MODE_SUPPORT (STD_OFF)
[!ENDIF!]
/**
* @brief          Support Interrupt for S32K118.
* @details        This parameter is enabled only on S32K118 derivative.
*/
[!IF "ecu:has('Can.Interrupt.Support')='true'"!]
    #define CAN_UNIFIED_INTERRUPTS (STD_ON)
[!ELSE!]
    #define CAN_UNIFIED_INTERRUPTS (STD_OFF)
[!ENDIF!]
/**
* @brief          Support for Wakeup feature.
* @details        This parameter is enabled only for platforms which have wakeup were suppoted. This platform isn't supported Wakeup.
*/
#define CAN_ENABLE_WAKEUP_SUPPORT (STD_OFF)

#ifndef MCAL_ENABLE_USER_MODE_SUPPORT
[!WS "4"!]#if (STD_ON == CAN_ENABLE_USER_MODE_SUPPORT)
    [!WS "8"!]#error MCAL_ENABLE_USER_MODE_SUPPORT is not enabled. For running Can in user mode the MCAL_ENABLE_USER_MODE_SUPPORT needs to be defined
[!WS "4"!]#endif /* (STD_ON == CAN_ENABLE_USER_MODE_SUPPORT) */
#endif /* ifndef MCAL_ENABLE_USER_MODE_SUPPORT */ 


[!IF "ecu:has('Can.CanGeneral.CanHwUnderRegProtList')"!]
    [!VAR "numProtectedCtrl" = "0"!]
    [!VAR "listProtectedCtrl" = "ecu:get('Can.CanGeneral.CanHwUnderRegProtList')"!]
    [!VAR "numProtectedCtrl" = "count(text:split($listProtectedCtrl, ','))"!]
    [!IF "num:i($numProtectedCtrl) != 0"!]
        /**
        * @brief          Support for User Mode feature.
        * @details        This parameters are defined only at least the Can controller that has registers under REG_PROT protection.
        */
        #define CAN_FLEXCAN_REG_PROT_AVAILABLE
    [!ENDIF!]

    [!LOOP "text:split($listProtectedCtrl, ',')"!]
        #define [!WS "1"!][!"text:toupper(normalize-space(node:current()))"!]_REG_PROT_AVAILABLE[!CR!]
    [!ENDLOOP!]
[!ENDIF!]

/**
* @brief          Implicit index value used by Full can hardware objects.
* @details        Implicit index value used by Full can hardware objects.
*
*/
/* @violates @ref Can_Cfg_h_REF_3 Violates MISRA 2004 Required Rule 19.4, source code mentenability. */
#define CAN_MAXMASKCOUNT    (Can_HwHandleType)65535U

/**
* @brief          Can Controllers. Defines for conversion between object names and object IDs.
* @details        Can Controllers. Defines for conversion between object names and object IDs.
                  (PR-MCAL-2944)Numeric ID's in configuration and definition of symbolic names in Can_Cfg.h file
*
*/
[!NOCODE!]
[!// Loop on all Configuration Sets
[!SELECT "CanConfigSet"!][!//
    [!VAR "ConfigSetIndex" = "0"!][!//
    [!LOOP "CanController/*"!][!//
    [!// Loop on all channels inside the same Configuration Set
        [!VAR "SavedIndex" = "CanControllerId"!][!//
        [!VAR "Name" = "@name"!][!//
        [!// Loop on all other Configuration Sets
        [!LOOP "../../../*[@index>$ConfigSetIndex]/CanController/*"!][!//
            [!IF "($Name = node:name(.))"!][!//
                [!IF "($SavedIndex != CanControllerId)"!][!//
                    [!// Error!!!!!!!!
                    [!ERROR!][!//
                        [!"$Name"!][!"'- Symbolic name for controller Ids can be repeated only if they have the same CanControllerId in each of the config set.'"!][!//
                    [!ENDERROR!][!//
                [!ENDIF!][!//
            [!ENDIF!][!//
        [!ENDLOOP!][!//     
    [!ENDLOOP!][!//
[!ENDSELECT!]
[!/* Check status of CanHwFilter and CanMainFunctionRWPeriodRef */!]
[!SELECT "CanConfigSet"!]
    [!LOOP "CanHardwareObject/*"!]
        [!IF "(((CanObjectType = 'RECEIVE') and ((node:ref(CanControllerRef)/CanRxProcessing) = 'POLLING')) or ((CanObjectType = 'TRANSMIT') and (node:value((node:ref(CanControllerRef)/CanTxProcessing)) = 'POLLING'))) and (not(node:exists(CanMainFunctionRWPeriodRef)))"!]
            [!ERROR!]
                The "CanMainFunctionRWPeriodRef" must be enabled when user configure the Can controller operate in the POLLING mode (both to transmission and reception)
            [!ENDERROR!]
        [!ENDIF!]
        [!IF "((CanObjectType = 'RECEIVE')) and (not(node:exists(CanHwFilter)))"!]
            [!ERROR!]
            The "CanHwFilter" of each HOH must be enabled when user configure HOH is receive.
            [!ENDERROR!]
        [!ENDIF!]
    [!ENDLOOP!]
[!ENDSELECT!]
[!ENDNOCODE!]
[!/* Check if two controllers have the same name in any ConfigSet */!]
[!VAR "OuterLoopCounter" = "0"!][!VAR "InnerLoopCounter" = "0"!]
[!LOOP "CanConfigSet/CanController/*"!]
    [!VAR "OuterLoopCounter" = "$OuterLoopCounter + 1"!]
    [!VAR "InnerLoopCounter" = "0"!]
    [!VAR "Matchcounter" = "0"!]
    [!VAR "Name" = "node:name(.)"!]
    [!LOOP "../../CanController/*"!]
        [!VAR "InnerLoopCounter" = "$InnerLoopCounter + 1"!]
        [!IF "$OuterLoopCounter >= $InnerLoopCounter"!]
            [!IF "($Name = node:name(.))"!]
                [!VAR "Matchcounter" = "$Matchcounter + 1"!]
            [!ENDIF!]
        [!ENDIF!]
    [!ENDLOOP!]
    [!IF "$Matchcounter = 1"!]
            #define CanConf_CanController_[!"@name"!] ((uint8)[!"CanControllerId"!]U)[!CR!]
    [!ELSE!]
        [!WARNING!] Some controllers have identical name. Should avoid this because of multiple generated DEFINEs with the same name![!ENDWARNING!]
    [!ENDIF!]
[!ENDLOOP!]

/**
* @brief          Can Hardware Objects.
* @details        Can Hardware Objects.
                  (PR-MCAL-2944)Numeric ID's in configuration and definition of symbolic names in Can_Cfg.h file.
*
*/
[!NOCODE!][!//
// Loop on all Configuration Sets to check if the symbolic names are duplicated between config sets
[!SELECT "CanConfigSet"!][!//
    [!VAR "ConfigSetIndex" = "0"!][!//
    // Loop on all channels inside the same Configuration Set
    [!LOOP "CanHardwareObject/*"!][!//
    [!VAR "SavedIndex" = "CanObjectId"!][!//
        [!VAR "Name" = "@name"!][!//
        // Loop on all other Configuration Sets
        [!LOOP "../../../*[@index>$ConfigSetIndex]/CanHardwareObject/*"!][!//
            [!IF "($Name = node:name(.))"!][!//
                [!IF "($SavedIndex != CanObjectId)"!][!//
                    // Error!!!!!!!!
                    [!ERROR!][!//
                        [!"$Name"!][!"'- Symbolic name for hardware object Ids can be repeated only if they have the same value for CanObjectId in each of the config set.'"!][!//
                    [!ENDERROR!][!//
                [!ENDIF!][!//
            [!ENDIF!][!//
        [!ENDLOOP!][!//     
    [!ENDLOOP!][!//
[!ENDSELECT!]
 
[!VAR "OuterLoopCounter" = "0"!][!VAR "InnerLoopCounter" = "0"!]
[!LOOP "CanConfigSet/CanHardwareObject/*"!]
    [!VAR "OuterLoopCounter" = "$OuterLoopCounter + 1"!]
    [!VAR "InnerLoopCounter" = "0"!]
    [!VAR "Matchcounter" = "0"!]
    [!VAR "Name" = "node:name(.)"!]
    [!LOOP "../../CanHardwareObject/*"!]
        [!VAR "InnerLoopCounter" = "$InnerLoopCounter + 1"!]
        [!IF "$OuterLoopCounter >= $InnerLoopCounter"!]
            [!IF "($Name = node:name(.))"!]
                [!VAR "Matchcounter" = "$Matchcounter + 1"!]
            [!ENDIF!]
        [!ENDIF!]
    [!ENDLOOP!]
    [!IF "$Matchcounter != 1"!]
        [!WARNING!] Some MBs have identical name. Should avoid this because of multiple generated DEFINEs with the same name![!ENDWARNING!]
    [!ENDIF!]
[!ENDLOOP!]

[!SELECT "CanConfigSet"!]
    [!VAR "MaxObjectIdForReceiveHO" = "0"!]
    [!LOOP "CanHardwareObject/*"!]
        [!IF "CanObjectType = 'RECEIVE'"!]
            [!IF "$MaxObjectIdForReceiveHO < CanObjectId"!]
                [!VAR "MaxObjectIdForReceiveHO" = "CanObjectId"!]
            [!ENDIF!]
        [!ENDIF!]
    [!ENDLOOP!]
    [!LOOP "CanHardwareObject/*"!]
        [!IF "CanObjectType = 'TRANSMIT'"!]
            [!IF "$MaxObjectIdForReceiveHO >= CanObjectId"!]
                [!ERROR!]
                The HRH and HTH Ids are defined under two different name-spaces (Refer to CAN326).
                Example: HRH0-0, HRH1-1, HTH0-2, HTH1-3.
                The HRHs of all controllers are grouped before the HTHs of all controllers
                    (there must not be any HTH of any controller with an object ID lower than
                    that of any HRH configured for this driver).
                [!ENDERROR!]
            [!ENDIF!]
        [!ENDIF!]
    [!ENDLOOP!]
    [!LOOP "CanHardwareObject/*"!]
        [!IF "@index > 0"!]
          [!FOR "x" = "0" TO "num:i(@index)"!]
            [!IF "num:i(CanObjectId) = num:i(../*[position() = ($x+1)]/CanObjectId)"!]
                [!IF "contains(node:path(node:ref(CanControllerRef)), node:path(node:ref(../*[position() = ($x+1)]/CanControllerRef)))"!]
                [!ELSE!]
                    [!ERROR!]
                    If Multiplex transmission = ON, the Hardware Objects that has the same CanObjectId must refer to the same controller, and must be of type TRANSMIT.
                    CanHardwareOblect "[!"node:name(.)"!]" and "[!"node:name(../*[position() = ($x+1)])"!]" have the same CanObjectId but refer to different controllers.
                    [!ENDERROR!]
                [!ENDIF!]
            [!ENDIF!]
          [!ENDFOR!]
        [!ENDIF!]
    [!ENDLOOP!]
[!ENDSELECT!]
[!ENDNOCODE!]


/*
* @brief          Symbolic names for CanObjectId
* @details        Symbolic names for CanObjectId maintained for compatibility with old testcases/applications 
*
*/
[!SELECT "CanConfigSet"!][!//
 [!LOOP "CanHardwareObject/*"!]
    [!IF "CanObjectType = 'RECEIVE'"!]
        #define [!WS "1"!][!"@name"!] [!WS "1"!][!"num:i(CanObjectId)"!]U /* RECEIVE object of Can Controller ID = [!"num:i(node:ref(CanControllerRef)/CanControllerId)"!] */[!CR!]
    [!ENDIF!]
[!ENDLOOP!]
[!ENDSELECT!]
[!SELECT "CanConfigSet"!][!//
[!LOOP "CanHardwareObject/*"!]
    [!IF "CanObjectType = 'TRANSMIT'"!]
        #define [!WS "1"!][!"@name"!] [!WS "1"!][!"num:i(CanObjectId)"!]U /* TRANSMIT object of Can Controller ID = [!"num:i(node:ref(CanControllerRef)/CanControllerId)"!] */[!CR!]
    [!ENDIF!]
[!ENDLOOP!]
[!ENDSELECT!]

/*
* @brief          Lpdu callout name
* @details        (CAN357_Conf) CanLPduReceiveCalloutFunction - This parameter sets the name of the LPDU callout.
*
*/
[!IF "node:exists(CanGeneral/CanLPduReceiveCalloutFunction) and (normalize-space(CanGeneral/CanLPduReceiveCalloutFunction) != 'NULL_PTR')"!]
    #define CAN_LPDU_NOTIFICATION_ENABLE  (STD_ON)
[!ELSE!]
    #define CAN_LPDU_NOTIFICATION_ENABLE  (STD_OFF)
[!ENDIF!]

/*
* @brief          Extended identifiers.
* @details        Extended identifiers.
                   - (STD_ON)  - if at least one extended identifier is used.
                   - (STD_OFF) - if no extended identifiers are used at all
                  If no extended identifiers are used then the IDs and MASKs can be stored in uint16 rather than uint32.
*
*/
#define CAN_EXTENDEDID [!WS "1"!][!IF "CanGeneral/CanExtendedIDSupport = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]

#define CAN_SET_BAUDRATE_API [!WS "1"!][!IF "((node:exists(CanGeneral/CanSetBaudrateApi)) and (CanGeneral/CanSetBaudrateApi ='true'))"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]
 
/*
* @brief          Switches the Can_ChangeBaudrate API and Can_CheckBaudRate API ON or OFF.
* @details        (CAN460) Configuration of Can_CheckBaudrate(Controller, Baudrate): If Can supports changing of the
                  baudrate and thus this service, shall be configurable via CAN_CHANGE_BAUDRATE_SUPPORT
*
*/
#define CAN_CHANGE_BAUDRATE_API [!WS "1"!][!IF "CanGeneral/CanChangeBaudrateApi = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]

/*
* @brief          Switches the Development Error Detection and Notification ON or OFF.
* @details        (CAN028) Call the Development Error Tracer when DET is switched on and the Can module detects an error.
                  (CAN082) The detection of development errors is configurable (ON / OFF) at pre- compile time.
                  The switch CanDevErrorDetection (see chapter 10) shall activate or deactivate the detection of all development errors.
*
*/
#define CAN_DEV_ERROR_DETECT [!WS "1"!][!IF "CanGeneral/CanDevErrorDetection = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]

/*
* @brief          CAN driver support for multiple INTERRUPTs.
* @details        CAN driver support for multiple INTERRUPTs.
*
*/
#define CAN_MULTIPLE_INTERRUPTS_SUPPORT [!WS "1"!][!IF "ecu:get('Can.CanConfig.MultipleInterrupts')='STD_ON'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]

/*
* @brief          Extended number of can hardware objects
* @details        Extended number of can hardware objects:
                   - STD_ON if more than 256 can hardware objects are needed (up to 65536)
                   - STD_OFF if no more than 256 can hardware objects are needed
                   The specification only allows up to 256 can hardware objects. The driver supports a non-standard extension of this limit.
@violates @ref Can_Cfg_h_REF_3 Violates MISRA 2004 Required Rule 19.4, source code mentenability.
*
*/
#define CAN_MBCOUNTEXTENSION [!WS "1"!][!IF "CanGeneral/CanMBCountExtensionSupport = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]

/*
* @brief          Support for version info API
* @details        Switches the Can_GetVersionInfo() API ON or OFF.
*
*/
#define CAN_VERSION_INFO_API [!WS "1"!][!IF "CanGeneral/CanVersionInfoApi = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]

/*
* @brief          Support for Multiplexed Transmision
* @details        MB set for Tx is put on bus from any TxMB that is available (free).
*                 (CAN277) The Can module shall allow that the functionality Multiplexed Transmission is statically configurable (ON | OFF) at pre-compile time.
*
*/
#define CAN_MULTIPLEXED_TRANSMISSION [!WS "1"!][!IF "CanGeneral/CanMultiplexedTransmission = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]

/*
* @brief          Support for Transmision Cancellation
* @details        Support for Transmision Cancellation
*                 (CAN278) The Can module shall allow that the functionality Transmit Cancellation is statically configurable (ON | OFF) at pre-compile time.
*
*/
#define CAN_HW_TRANSMIT_CANCELLATION (STD_OFF)

/*
* @brief          Support for Identical Id Cancellation
* @details        Enables/disables cancellation of pending PDUs with identical ID.
*
*/

/*
* @brief          Support for Special MB Abort API
* @details        Enable an additional API, to write an ABORT code (b1001) to the MBCB filed of the MB to abort a message transmission.
*
*/
#define CAN_API_ENABLE_ABORT_MB [!WS "1"!][!IF "(CanGeneral/CanApiEnableMbAbort = 'true')"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]

/*
* @brief          Support for MB Abort  API
* @details         This parameter is enabled only if CanMultiplexedTransmission=STD_ON and aborts only one message buffer
*/
#define CAN_ABORT_ONLY_ONE_MB [!WS "1"!][!IF "(CanGeneral/CanAbortOnlyOneMB = 'true') and (CanGeneral/CanApiEnableMbAbort = 'true')"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]

/*
* @brief          Instance # of the driver - used for Det_ReportError().
* @details        Instance # of the driver - used for Det_ReportError().
*
*/
#define CAN_INSTANCE [!WS "1"!][!"num:i(CanGeneral/CanIndex)"!]U

/*
* @brief          The define in order to check the trigger transmit feature is enabled or disabled.
* @details        The define in order to check the trigger transmit feature is enabled or disabled.
*
*/
[!IF "num:i(count(CanConfigSet/CanHardwareObject/*[CanTriggerTransmitEnable = 'true'])) > 0"!]
    #define CAN_TRIGGER_TRANSMIT_EN (STD_ON)
[!ELSE!]
    #define CAN_TRIGGER_TRANSMIT_EN (STD_OFF)
[!ENDIF!]

/*
* @brief          Platform support mix of controllers with 64 and 32 MBs.
* @details        Platform support mix of controllers with 64 and 32 MBs.
*
*/
#define CAN_MIX_MB_SUPPORT  [!WS "1"!][!IF "ecu:get('Can.CanConfig.MixMB')='STD_ON'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]

/*
* @brief          Platform support for detection and correction of memory errors
* @details        Platform support for detection and correction of memory errors
*
*/
#define CAN_MEMORY_ECC_SUPPORT  [!WS "1"!][!IF "ecu:get('Can.CanConfig.MemoryECC')='STD_ON'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]

[!IF "ecu:has('Can.CanGeneral.FixNoFifoFilterAndMask')"!][!//
    [!IF "ecu:get('Can.CanGeneral.FixNoFifoFilterAndMask')='STD_ON'"!][!//
        /*
        * @brief          Platform not support Selectable number of Fifo filter element and Global Fifo filter mask
        * @details        Platform not support Selectable number (fix to 8 filter elements) of Fifo filter element and Global Fifo filter mask
        *
        */

        #define CAN_NOT_SUPPORT_CTRL2_RXFGMASK  [!WS "1"!](STD_ON)
    [!ENDIF!][!//
[!ENDIF!][!//

/*
* @brief          Disable errata e10368 in some derivative
* @details        In some derivative, it is not impacted by errata e10368. This define is for removing workaround when using these derivative.
*
*/
[!IF "ecu:has('Can.CanGeneral.DisableE10368')"!][!//
    [!IF "ecu:get('Can.CanGeneral.DisableE10368')='STD_ON'"!][!//
        #define CAN_E10368_INCONSISTENT  [!WS "1"!](STD_ON)
    [!ELSE!]
        #define CAN_E10368_INCONSISTENT  [!WS "1"!](STD_OFF)
    [!ENDIF!][!//
[!ELSE!]
        #define CAN_E10368_INCONSISTENT  [!WS "1"!](STD_OFF)
[!ENDIF!][!//


/*
* @brief          Platform support for Pretended Networking
* @details        Platform support for Pretended Networking
*
*/
[!IF "(CanGeneral/CanPublicIcomSupport  = 'true') and (ecu:get('Can.CanConfigSet.CanPretendedNetworking')='STD_ON')"!]
  [!SELECT "CanConfigSet"!]
    [!IF "node:exists(CanIcom)"!]
        #define CAN_PRETENDED_MAX_CONFIG    ((uint8)[!"num:i(count(CanIcom/CanIcomConfig/*))"!]U)
      [!IF "node:exists(CanIcom/CanIcomConfig/*/CanIcomWakeupCauses/CanIcomRxMessage/*/CanIcomMissingMessageTimerValue)"!]
        #define CAN_PRETENDED_TIMEOUT_CHECK (STD_ON)
      [!ELSE!]
        #define CAN_PRETENDED_TIMEOUT_CHECK (STD_OFF)
      [!ENDIF!]
        [!IF "node:exists(CanIcom/CanIcomConfig/*/CanIcomWakeupCauses/CanIcomRxMessage/*/CanIcomCounterValue)"!]
            #define CAN_PRETENDED_COUNT_MESSAGE (STD_ON)
        [!ELSE!]
            #define CAN_PRETENDED_COUNT_MESSAGE (STD_OFF)
        [!ENDIF!]
    [!ELSE!]
        #define CAN_PRETENDED_TIMEOUT_CHECK (STD_OFF)
    [!ENDIF!]
  [!ENDSELECT!]
[!ENDIF!]
/*
* @brief          Maximum number of Message Buffers configured.
* @details        Maximum number of Message Buffers configured.
*
*/
[!SELECT "CanConfigSet"!]
    [!VAR "max_ctrl" = "ecu:get('Can.CanConfigSet.CanController')"!]
    [!VAR "ctrls" = "num:i(count(CanController/*))"!][!VAR "mbs" = "num:i(count(CanHardwareObject/*))"!]
    [!IF "( ($ctrls > $max_ctrl) or ($mbs > ($ctrls*(ecu:get('Can.CanConfigSet.CanMB')))) )"!]
        [!ERROR!]Too many MBs for the number of controllers configured.[!ENDERROR!]
    [!ELSE!]
        #define CAN_MAXMBCOUNT_0 [!WS "1"!][!"num:i(count(CanHardwareObject/*))"!]U
    [!ENDIF!]
[!ENDSELECT!]


/*
* @brief          Maximum possible Message Buffers per controller specific to this platform.
* @details        Maximum possible Message Buffers per controller specific to this platform.
*
*/
[!VAR "max_mb_value" = "num:i(ecu:get('Can.CanConfigSet.CanMB'))"!]
[!IF "($max_mb_value <=32)"!]
    #define CAN_MAXMB_SUPPORTED 32U
[!ELSEIF "(($max_mb_value > 32) and ($max_mb_value <=64))"!]
    #define CAN_MAXMB_SUPPORTED 64U
[!ELSEIF "(($max_mb_value > 64) and ($max_mb_value <=96))"!]
    #define CAN_MAXMB_SUPPORTED 96U
[!ENDIF!]

/*
* @brief          Maximum number of Message Buffers configured.
* @details        Maximum number of Message Buffers configured.
*
*/
#define CAN_MAXMB_CONFIGURED [!WS "1"!][!SELECT "CanGeneral"!][!"num:i(CanMaxMessageBuffers)"!]U[!ENDSELECT!][!CR!]

/*
* @brief          Maximum possible controllers per specific derivative.
* @details        Maximum possible controllers per specific derivative.
*
*/
#define CAN_MAXCTRL_SUPPORTED [!WS "1"!][!"num:i(ecu:get('Can.CanConfigSet.CanController'))"!]U

/**
* @brief          Maximum No. of supported controllers (vary according to Processor Family).
* @details        Maximum No. of supported controllers (vary according to Processor Family).
*
*/
[!IF "IMPLEMENTATION_CONFIG_VARIANT='VariantPreCompile'"!]
    [!SELECT "CanConfigSet"!][!//
        [!VAR "ctrls" = "num:i(count(CanController/*))"!]
        [!IF "$ctrls > $max_ctrl"!]
            [!ERROR!]Target supports maximum [!"num:i(ecu:get('Can.CanConfigSet.CanController'))"!] controllers.[!ENDERROR!]
        [!ELSE!]
            #define CAN_MAXCONTROLLERCOUNT_0 [!WS "1"!][!"$ctrls"!]U[!CR!]
        [!ENDIF!]
    [!ENDSELECT!]
[!ELSE!]
    [!SELECT "CanConfigSet"!][!//
        [!VAR "ctrls" = "num:i(count(CanController/*))"!]
        [!IF "$ctrls > $max_ctrl"!]
            [!ERROR!]Target supports maximum [!"num:i(ecu:get('Can.CanConfigSet.CanController'))"!] controllers.[!ENDERROR!]
        [!ELSE!]
            #define CAN_MAXCONTROLLERCOUNT_0 [!WS "1"!][!"$ctrls"!]U[!CR!]
        [!ENDIF!]
    [!ENDSELECT!]
[!ENDIF!]

/*
* @brief          Maximum No. of controllers Configured
* @details      Maximum No. of controllers Configured
*
*/
[!NOCODE!]
[!VAR "flexcans" = "0"!]
[!SELECT "CanConfigSet"!]
    [!VAR "flexcans" = "num:i(count(CanController/*))"!] 
[!ENDSELECT!]
[!ENDNOCODE!]
#define CAN_MAXCTRL_CONFIGURED [!WS "1"!][!"$flexcans"!]U

/**
* @brief          Hardware events detected by an INTERRUPT or by POLLING
* @details        (CAN099) The hardware events may be detected by an INTERRUPT or by POLLING status flags of the hardware objects.
*                 The configuration possibilities regarding POLLING is hardware dependent (i.e. which events can be polled, which events need to be polled), and not restricted by this standard.
*                 (CAN007)It shall be possible to configure the driver such that no INTERRUPTs at all are used (complete POLLING).
*
*/
[!NOCODE!]
[!VAR "int_en_a"="0"!]
[!VAR "int_en_b"="0"!]
[!VAR "int_en_c"="0"!]
[!VAR "int_en_d"="0"!]
[!VAR "int_en_e"="0"!]
[!VAR "int_en_f"="0"!]
[!VAR "int_en_g"="0"!]
[!VAR "int_en_h"="0"!]
[!VAR "tx_pol_en"="0"!]
[!VAR "tx_int_en"="0"!]
[!SELECT "CanConfigSet"!][!//
    [!LOOP "CanController/*"!]
        [!IF "CanTxProcessing = 'POLLING'"!]
            [!VAR "tx_pol_en" = "1"!]
        [!ELSE!]
            [!VAR "tx_int_en"= "1"!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_A'"!]
            [!IF "CanTxProcessing = 'INTERRUPT'"!]
                [!VAR "int_en_a" = "1"!]
            [!ELSE!]
                [!VAR "int_en_a" = "2"!]
            [!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_B'"!]
            [!IF "CanTxProcessing = 'INTERRUPT'"!]
                [!VAR "int_en_b" = "1"!]
            [!ELSE!]
                [!VAR "int_en_b" = "2"!]
            [!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_C'"!]
            [!IF "CanTxProcessing = 'INTERRUPT'"!]
                [!VAR "int_en_c" = "1"!]
            [!ELSE!]
                [!VAR "int_en_c" = "2"!]
            [!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_D'"!]
            [!IF "CanTxProcessing = 'INTERRUPT'"!]
                [!VAR "int_en_d" = "1"!]
            [!ELSE!]
                [!VAR "int_en_d" = "2"!]
            [!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_E'"!]
            [!IF "CanTxProcessing = 'INTERRUPT'"!]
                [!VAR "int_en_e" = "1"!]
            [!ELSE!]
                [!VAR "int_en_e" = "2"!]
            [!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_F'"!]
            [!IF "CanTxProcessing = 'INTERRUPT'"!]
                [!VAR "int_en_f" = "1"!]
            [!ELSE!]
                [!VAR "int_en_f" = "2"!]
            [!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_G'"!]
            [!IF "CanTxProcessing = 'INTERRUPT'"!]
                [!VAR "int_en_g" = "1"!]
            [!ELSE!]
                [!VAR "int_en_g" = "2"!]
            [!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_H'"!]
            [!IF "CanTxProcessing = 'INTERRUPT'"!]
                [!VAR "int_en_h" = "1"!]
            [!ELSE!]
                [!VAR "int_en_h" = "2"!]
            [!ENDIF!]
        [!ENDIF!]   
    [!ENDLOOP!]
[!ENDSELECT!]
[!ENDNOCODE!]
/**
* @brief          This macros enable INTERRUPTs for controllers if Tx processing is set to INTERRUPT Mode.
* @details        This macros enable INTERRUPTs for controllers if Tx processing is set to INTERRUPT Mode.
*
*/
[!IF "$int_en_a!=0"!]#define CAN_A_TXINT_SUPPORTED  [!IF "$int_en_a = 1"!][!WS "1"!](STD_ON)[!ELSEIF "$int_en_a = 2"!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
[!IF "$int_en_b!=0"!]#define CAN_B_TXINT_SUPPORTED  [!IF "$int_en_b = 1"!][!WS "1"!](STD_ON)[!ELSEIF "$int_en_b = 2"!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
[!IF "$int_en_c!=0"!]#define CAN_C_TXINT_SUPPORTED  [!IF "$int_en_c = 1"!][!WS "1"!](STD_ON)[!ELSEIF "$int_en_c = 2"!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
[!IF "$int_en_d!=0"!]#define CAN_D_TXINT_SUPPORTED  [!IF "$int_en_d = 1"!][!WS "1"!](STD_ON)[!ELSEIF "$int_en_d = 2"!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
[!IF "$int_en_e!=0"!]#define CAN_E_TXINT_SUPPORTED  [!IF "$int_en_e = 1"!][!WS "1"!](STD_ON)[!ELSEIF "$int_en_e = 2"!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
[!IF "$int_en_f!=0"!]#define CAN_F_TXINT_SUPPORTED  [!IF "$int_en_f = 1"!][!WS "1"!](STD_ON)[!ELSEIF "$int_en_f = 2"!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
[!IF "$int_en_g!=0"!]#define CAN_G_TXINT_SUPPORTED  [!IF "$int_en_g = 1"!][!WS "1"!](STD_ON)[!ELSEIF "$int_en_g = 2"!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
[!IF "$int_en_h!=0"!]#define CAN_H_TXINT_SUPPORTED  [!IF "$int_en_h = 1"!][!WS "1"!](STD_ON)[!ELSEIF "$int_en_h = 2"!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]

/*
* @brief          This macro enables Can_MainFunction_Write() if at least one controller is set to process Tx in POLLING Mode.
* @details        This macro enables Can_MainFunction_Write() if at least one controller is set to process Tx in POLLING Mode.
*
*/
#define CAN_TXPOLL_SUPPORTED   [!IF "$tx_pol_en = 1"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!]

[!NOCODE!]
[!VAR "int_en_a"="0"!]
[!VAR "int_en_b"="0"!]
[!VAR "int_en_c"="0"!]
[!VAR "int_en_d"="0"!]
[!VAR "int_en_e"="0"!]
[!VAR "int_en_f"="0"!]
[!VAR "int_en_g"="0"!]
[!VAR "int_en_h"="0"!]
[!VAR "rx_pol_en"="0"!]
[!VAR "rx_int_en"="0"!]
[!SELECT "CanConfigSet"!]
    [!LOOP "CanController/*"!]
        [!IF "CanRxProcessing = 'POLLING'"!]
            [!VAR "rx_pol_en" = "1"!]
        [!ELSE!]
            [!VAR "rx_int_en" = "1"!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_A'"!]
            [!IF "CanRxProcessing = 'INTERRUPT'"!]
                [!VAR "int_en_a" = "1"!]
            [!ELSE!]
                [!VAR "int_en_a" = "2"!]
            [!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_B'"!]
            [!IF "CanRxProcessing = 'INTERRUPT'"!]
                [!VAR "int_en_b" = "1"!]
            [!ELSE!]
                [!VAR "int_en_b" = "2"!]
            [!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_C'"!]
            [!IF "CanRxProcessing = 'INTERRUPT'"!]
                [!VAR "int_en_c" = "1"!]
            [!ELSE!]
                [!VAR "int_en_c" = "2"!]
            [!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_D'"!]
            [!IF "CanRxProcessing = 'INTERRUPT'"!]
                [!VAR "int_en_d" = "1"!]
            [!ELSE!]
                [!VAR "int_en_d" = "2"!]
            [!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_E'"!]
            [!IF "CanRxProcessing = 'INTERRUPT'"!]
                [!VAR "int_en_e" = "1"!]
            [!ELSE!]
                [!VAR "int_en_e" = "2"!]
            [!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_F'"!]
            [!IF "CanRxProcessing = 'INTERRUPT'"!]
                [!VAR "int_en_f" = "1"!]
            [!ELSE!]
                [!VAR "int_en_f" = "2"!]
            [!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_G'"!]
            [!IF "CanRxProcessing = 'INTERRUPT'"!]
                [!VAR "int_en_g" = "1"!]
            [!ELSE!]
                [!VAR "int_en_g" = "2"!]
            [!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_H'"!]
            [!IF "CanRxProcessing = 'INTERRUPT'"!]
                [!VAR "int_en_h" = "1"!]
            [!ELSE!]
                [!VAR "int_en_h" = "2"!]
            [!ENDIF!]
        [!ENDIF!]   
    [!ENDLOOP!]
[!ENDSELECT!]
[!ENDNOCODE!]
/**
* @brief          This macros enable INTERRUPTs for controllers if Rx processing is set to INTERRUPT Mode.
* @details        This macros enable INTERRUPTs for controllers if Rx processing is set to INTERRUPT Mode.
*
*/
[!IF "$int_en_a!=0"!]#define CAN_A_RXINT_SUPPORTED  [!WS "1"!][!IF "$int_en_a = 1"!](STD_ON)[!ELSEIF "$int_en_a = 2"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
[!IF "$int_en_b!=0"!]#define CAN_B_RXINT_SUPPORTED  [!WS "1"!][!IF "$int_en_b = 1"!](STD_ON)[!ELSEIF "$int_en_b = 2"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
[!IF "$int_en_c!=0"!]#define CAN_C_RXINT_SUPPORTED  [!WS "1"!][!IF "$int_en_c = 1"!](STD_ON)[!ELSEIF "$int_en_c = 2"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
[!IF "$int_en_d!=0"!]#define CAN_D_RXINT_SUPPORTED  [!WS "1"!][!IF "$int_en_d = 1"!](STD_ON)[!ELSEIF "$int_en_d = 2"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
[!IF "$int_en_e!=0"!]#define CAN_E_RXINT_SUPPORTED  [!WS "1"!][!IF "$int_en_e = 1"!](STD_ON)[!ELSEIF "$int_en_e = 2"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
[!IF "$int_en_f!=0"!]#define CAN_F_RXINT_SUPPORTED  [!WS "1"!][!IF "$int_en_f = 1"!](STD_ON)[!ELSEIF "$int_en_f = 2"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
[!IF "$int_en_g!=0"!]#define CAN_G_RXINT_SUPPORTED  [!WS "1"!][!IF "$int_en_g = 1"!](STD_ON)[!ELSEIF "$int_en_g = 2"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
[!IF "$int_en_h!=0"!]#define CAN_H_RXINT_SUPPORTED  [!WS "1"!][!IF "$int_en_h = 1"!](STD_ON)[!ELSEIF "$int_en_h = 2"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]

/*
* @brief          This macro enables Can_MainFunction_Read() if at least one controller is set to process Rx in POLLING Mode.
* @details        This macro enables Can_MainFunction_Read() if at least one controller is set to process Rx in POLLING Mode.
*
*/
#define CAN_RXPOLL_SUPPORTED   [!IF "$rx_pol_en = 1"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!]

/*
* @brief          This macro enables Can_ProcessTx() and Can_ProcessRx() if at least one controller is set to process TX/Rx in INTERRUPT Mode.
* @details        This macro enables Can_ProcessTx() and Can_ProcessRx() if at least one controller is set to process TX/Rx in INTERRUPT Mode.
*
*/
[!IF "($tx_int_en = 1) or ($rx_int_en = 1)"!]
    #define CAN_TX_RX_INTR_SUPPORTED    (STD_ON)
[!ELSE!]
    #define CAN_TX_RX_INTR_SUPPORTED    (STD_OFF)
[!ENDIF!]

[!NOCODE!]
[!VAR "int_en_a"="0"!]
[!VAR "int_en_b"="0"!]
[!VAR "int_en_c"="0"!]
[!VAR "int_en_d"="0"!]
[!VAR "int_en_e"="0"!]
[!VAR "int_en_f"="0"!]
[!VAR "int_en_g"="0"!]
[!VAR "int_en_h"="0"!]
[!VAR "bo_pol_en"="0"!]
[!SELECT "CanConfigSet"!][!//
    [!LOOP "CanController/*"!]
        [!IF "CanBusoffProcessing = 'POLLING'"!]
            [!VAR "bo_pol_en" = "1"!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_A'"!]
            [!IF "CanBusoffProcessing = 'INTERRUPT'"!]
                [!VAR "int_en_a" = "1"!]
            [!ELSE!]
                [!VAR "int_en_a" = "2"!]
            [!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_B'"!]
            [!IF "CanBusoffProcessing = 'INTERRUPT'"!]
                [!VAR "int_en_b" = "1"!]
            [!ELSE!]
                [!VAR "int_en_b" = "2"!]
            [!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_C'"!]
            [!IF "CanBusoffProcessing = 'INTERRUPT'"!]
                [!VAR "int_en_c" = "1"!]
            [!ELSE!]
                [!VAR "int_en_c" = "2"!]
            [!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_D'"!]
            [!IF "CanBusoffProcessing = 'INTERRUPT'"!]
                [!VAR "int_en_d" = "1"!]
            [!ELSE!]
                [!VAR "int_en_d" = "2"!]
            [!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_E'"!]
            [!IF "CanBusoffProcessing = 'INTERRUPT'"!]
                [!VAR "int_en_e" = "1"!]
            [!ELSE!]
                [!VAR "int_en_e" = "2"!]
            [!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_F'"!]
            [!IF "CanBusoffProcessing = 'INTERRUPT'"!]
                [!VAR "int_en_f" = "1"!]
            [!ELSE!]
                [!VAR "int_en_f" = "2"!]
            [!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_G'"!]
            [!IF "CanBusoffProcessing = 'INTERRUPT'"!]
                [!VAR "int_en_g" = "1"!]
            [!ELSE!]
                [!VAR "int_en_g" = "2"!]
            [!ENDIF!]
        [!ENDIF!]
        [!IF "CanHwChannel = 'FlexCAN_H'"!]
            [!IF "CanBusoffProcessing = 'INTERRUPT'"!]
                [!VAR "int_en_h" = "1"!]
            [!ELSE!]
                [!VAR "int_en_h" = "2"!]
            [!ENDIF!]
        [!ENDIF!]   
    [!ENDLOOP!]
[!ENDSELECT!]
[!ENDNOCODE!]
/**
* @brief          This macros enable INTERRUPTs for controllers if BusOff processing is set to INTERRUPT Mode.
* @details        This macros enable INTERRUPTs for controllers if BusOff processing is set to INTERRUPT Mode.
*
*/
[!IF "$int_en_a!=0"!]#define CAN_A_BUSOFFINT_SUPPORTED  [!IF "$int_en_a = 1"!][!WS "1"!](STD_ON)[!ELSEIF "$int_en_a = 2"!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
[!IF "$int_en_b!=0"!]#define CAN_B_BUSOFFINT_SUPPORTED  [!IF "$int_en_b = 1"!][!WS "1"!](STD_ON)[!ELSEIF "$int_en_b = 2"!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
[!IF "$int_en_c!=0"!]#define CAN_C_BUSOFFINT_SUPPORTED  [!IF "$int_en_c = 1"!][!WS "1"!](STD_ON)[!ELSEIF "$int_en_c = 2"!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
[!IF "$int_en_d!=0"!]#define CAN_D_BUSOFFINT_SUPPORTED  [!IF "$int_en_d = 1"!][!WS "1"!](STD_ON)[!ELSEIF "$int_en_d = 2"!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
[!IF "$int_en_e!=0"!]#define CAN_E_BUSOFFINT_SUPPORTED  [!IF "$int_en_e = 1"!][!WS "1"!](STD_ON)[!ELSEIF "$int_en_e = 2"!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
[!IF "$int_en_f!=0"!]#define CAN_F_BUSOFFINT_SUPPORTED  [!IF "$int_en_f = 1"!][!WS "1"!](STD_ON)[!ELSEIF "$int_en_f = 2"!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
[!IF "$int_en_g!=0"!]#define CAN_G_BUSOFFINT_SUPPORTED  [!IF "$int_en_g = 1"!][!WS "1"!](STD_ON)[!ELSEIF "$int_en_g = 2"!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]
[!IF "$int_en_h!=0"!]#define CAN_H_BUSOFFINT_SUPPORTED  [!IF "$int_en_h = 1"!][!WS "1"!](STD_ON)[!ELSEIF "$int_en_h = 2"!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!][!ENDIF!]

/*
* @brief          This macro enables Can_MainFunction_BusOff() if at least one controller is set to process BusOff in POLLING Mode.
* @details        This macro enables Can_MainFunction_BusOff() if at least one controller is set to process BusOff in POLLING Mode.
*
*/
#define CAN_BUSOFFPOLL_SUPPORTED   [!IF "$bo_pol_en = 1"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!]

/*
* @brief          Maximum number of MB Filters configured.
* @details        Maximum number of MB Filters configured.
*
*/
[!SELECT "CanConfigSet"!]
    #define CAN_MAXFILTERCOUNT_0 [!WS "1"!][!"num:i(count(CanHardwareObject/*/CanHwFilter/CanHwFilterMask))"!]U[!CR!]
[!ENDSELECT!]

/**
* @brief          Maximum number of baudrate configured.
* @details        Maximum number of baudrate configured.
*                 Controller Baudrates configured are in kbps
*
*/
[!IF "IMPLEMENTATION_CONFIG_VARIANT='VariantPreCompile'"!]
    [!SELECT "CanConfigSet"!][!//
        [!LOOP "CanController/*"!]
            [!VAR "HWChannel" = "CanHwChannel"!]
                [!LOOP "CanControllerBaudrateConfig/*"!]
                    #define CAN_CFGSET0_BAUDRATE_FC_[!"substring-after($HWChannel,'FlexCAN_')"!]_[!"@index"!]   [!WS "1"!] [!"CanControllerBaudRate"!]U[!CR!]
                [!ENDLOOP!]
                #define CAN_CFGSET0_MAX_BAUDRATE_FC_[!"substring-after($HWChannel,'FlexCAN_')"!]_[!"@index"!]   [!WS "1"!][!"num:i(count(CanControllerBaudrateConfig/*))"!]U[!CR!]
        [!ENDLOOP!]
    [!ENDSELECT!]
[!ELSE!]
    [!SELECT "CanConfigSet"!][!//
        [!VAR "CSET_NR" = "num:i(0)"!]
        [!LOOP "CanController/*"!]
            [!VAR "HWChannel" = "CanHwChannel"!]
            [!LOOP "CanControllerBaudrateConfig/*"!]
                #define CAN_CFGSET[!"num:i($CSET_NR)"!]_BAUDRATE_FC_[!"substring-after($HWChannel,'FlexCAN_')"!]_[!"@index"!]   [!WS "1"!][!"CanControllerBaudRate"!]U[!CR!]
            [!ENDLOOP!]
            #define CAN_CFGSET[!"num:i($CSET_NR)"!]_MAX_BAUDRATE_FC_[!"substring-after($HWChannel,'FlexCAN_')"!]_[!"@index"!]   [!WS "1"!][!"num:i(count(CanControllerBaudrateConfig/*))"!]U[!CR!]
        [!ENDLOOP!]
    [!ENDSELECT!] 
[!ENDIF!]

/* CAN FD INIT*/
[!NOCODE!]
[!VAR "CNT_FD" = "0"!]
[!SELECT "CanConfigSet"!][!//
[!IF "ecu:get('Can.CanConfigSet.CanFdEnable')='STD_ON'"!]
    [!IF "node:exists(CanController/*/CanControllerBaudrateConfig/*/CanControllerFdBaudrateConfig)"!]
        [!VAR "CNT_FD" = "$CNT_FD+1"!] 
    [!ENDIF!]
[!ENDIF!]    
[!ENDSELECT!]
[!ENDNOCODE!]
[!IF "$CNT_FD > 0"!]
    #define CAN_FD_MODE_ENABLE (STD_ON)
    [!VAR "CNT_FD" = "0"!]
[!ELSE!]
    #define CAN_FD_MODE_ENABLE (STD_OFF)
[!ENDIF!]
[!NOCODE!]
[!VAR "CNT_CBT" = "0"!]
[!SELECT "CanConfigSet"!][!//
[!IF "ecu:get('Can.CanConfigSet.CBTSupport')='STD_ON'"!]
    [!IF "(node:exists(CanController/*/CanControllerBaudrateConfig/*/CanControllerCBT/CanControllerCbtEnable))"!]
        [!IF "(node:value(CanController/*/CanControllerBaudrateConfig/*/CanControllerCBT/CanControllerCbtEnable))='true'"!]
            [!VAR "CNT_CBT" = "$CNT_CBT+1"!] 
        [!ENDIF!]
    [!ENDIF!]
[!ENDIF!]
[!ENDSELECT!]
[!ENDNOCODE!]
[!IF "$CNT_CBT > 0"!]
    #define CAN_CBT_ENABLE (STD_ON)
[!ELSE!]
    #define CAN_CBT_ENABLE (STD_OFF)
[!ENDIF!]

[!IF "ecu:get('Can.CanConfig.SwichingIsoMode')='STD_ON'"!]
    #define CAN_CONTROLLER_FD_ISO_CANFD (STD_ON)
[!ELSE!]
    #define CAN_CONTROLLER_FD_ISO_CANFD (STD_OFF)
[!ENDIF!]

[!IF "ecu:get('Can.CanConfigSet.ProtocolException')='STD_ON'"!]
    #define CAN_CONTROLLER_FD_PREXCEN (STD_ON)
[!ELSE!]
    #define CAN_CONTROLLER_FD_PREXCEN (STD_OFF)
[!ENDIF!]

[!IF "ecu:get('Can.CanConfigSet.EdgeFilter')='STD_ON'"!]
    #define CAN_CONTROLLER_FD_EDFLTDIS (STD_ON)
[!ELSE!]
    #define CAN_CONTROLLER_FD_EDFLTDIS (STD_OFF)
[!ENDIF!]

/*
* @brief          Maximum number of Filters configured for RxFifo.
* @details        Maximum number of Filters configured for RxFifo.
*
*/
[!SELECT "CanConfigSet"!][!VAR "TableIdCount" = "0"!]
    [!LOOP "CanController/*"!]
        [!IF "CanControllerRxFifoEnable = 'true'"!]
            [!VAR "TableIdCount" = "$TableIdCount+num:i(substring-after(./CanRxFifo/CanRxFifoFiltersNumber,'FILTERS_NUMBER_'))"!]
        [!ENDIF!]
    [!ENDLOOP!]
    [!IF "$TableIdCount != 0"!]
        #define CAN_MAXTABLEID_0 [!WS "1"!][!"num:i($TableIdCount)"!]U[!CR!]
    [!ENDIF!]
[!ENDSELECT!]

[!VAR "rxfifoenable" = "0"!]
[!LOOP "CanConfigSet/CanController/*"!]
    [!IF "CanControllerRxFifoEnable = 'true'"!]
        [!VAR "rxfifoenable" = "1"!]
    [!ENDIF!]
[!ENDLOOP!]

/*
* @brief          Support for Rx Fifo
* @details        Support for Rx Fifo - If at least one controller supports RxFifo, then this define is set to STD_ON.
*                 This define is global for the entire hardware unit (all controllers). Every controller has particular
*                 configuration for Rx Fifo (see Can_ControllerConfigType structure).
*
*/
#define CAN_RXFIFO_ENABLE [!IF "$rxfifoenable = 1"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!]

/*
* @brief          Set if Rx Fifo events (Warning/Overflow/FrameAvailable) are configured on the same int on INTC vector table.
* @details        Set if Rx Fifo events (Warning/Overflow/FrameAvailable) are configured on the same int on INTC vector table.
*                 Based on this define separate INTERRUPTs handlers or not will be used for the 3 events of the RxFifo.
*
*/
#define CAN_RXFIFO_EVENT_UNIFIED [!WS "1"!][!IF "ecu:get('Can.CanConfigSet.RxFifoEventsUnified')='STD_ON'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]

/*
* @brief          Error notification enabled/disabled.
* @details        Enables/Disables the Error Controller Notification. Used for INTERRUPTs mapping in Can_Irq.c file.
*
*/
#define CAN_ERROR_NOTIFICATION_ENABLE [!IF "CanConfigSet/CanController/*/CanErrorControllerNotifEn = 'true'"!][!WS "1"!](STD_ON)[!ELSE!][!WS "1"!](STD_OFF)[!ENDIF!][!CR!]

[!SELECT "CanConfigSet"!]
    [!LOOP "CanController/*"!]
        [!IF "CanHwChannel = 'FlexCAN_A'"!]
            /*
            * @brief          Index into the configuration structures.
            * @details        Index into the configuration structures.Indexes used for accessing the 'Can_ControlerDescriptorType' structure.
            *                 NOTE that index order from hardware (where CAN_A has always index 0, ..)
            *                 may not be the same with the order from the 'Can_ControlerDescriptorType' structure (where user can define controllers in any order).
            *                 Count also the number of controllers that have INTERRUPTs enabled.
            *
            */
            #define CAN_FCA_INDEX       ((uint8)[!"num:i(CanControllerId)"!]U)

            /*
            * @brief          Index into the hardware platform.
            * @details        Index into the hardware platform.Indexes used for accessing the 'Can_ControlerDescriptorType' structure.
            *
            */
            #define FLEXCAN_A_OFFSET    ((uint8)0U)
            
            /*
            * @brief          RxFifo Functionality enabled/disabled. Used for INTERRUPTs mapping in Can_Irq.c file.
            * @details        RxFifo Functionality enabled/disabled. Used for INTERRUPTs mapping in Can_Irq.c file.
            *
            */
            #define CAN_A_FIFO_EN       [!WS "1"!][!IF "CanControllerRxFifoEnable = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]
            
            /*
            * @brief          Error notification enabled/disabled.
            * @details        Enables/Disables the Error Controller Notification. Used for INTERRUPTs mapping in Can_Irq.c file.
            *
            */
            #define CAN_A_ERROR_NOTIFICATION_ENABLE  [!WS "1"!][!IF "CanErrorControllerNotifEn = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]
            
        [!ELSEIF "CanHwChannel = 'FlexCAN_B'"!]
            /*
            * @brief          Index into the configuration structures.
            * @details        Index into the configuration structures.
            *
            */
            #define CAN_FCB_INDEX       ((uint8)[!"num:i(CanControllerId)"!]U)
            
            /*
            * @brief          Index into the hardware platform.
            * @details        Index into the hardware platform.
            *
            */
            #define FLEXCAN_B_OFFSET    ((uint8)1U)
            
            /*
            * @brief          RxFifo Functionality enabled/disabled. Used for INTERRUPTs mapping in Can_Irq.c file.
            * @details        RxFifo Functionality enabled/disabled. Used for INTERRUPTs mapping in Can_Irq.c file.
            *
            */
            #define CAN_B_FIFO_EN       [!WS "1"!][!IF "CanControllerRxFifoEnable = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]
            
            /*
            * @brief          Error notification enabled/disabled.
            * @details        Enables/Disables the Error Controller Notification. Used for INTERRUPTs mapping in Can_Irq.c file.
            *
            */
            #define CAN_B_ERROR_NOTIFICATION_ENABLE  [!WS "1"!][!IF "CanErrorControllerNotifEn = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]
            
        [!ELSEIF "CanHwChannel = 'FlexCAN_C'"!]
            /*
            * @brief          Index into the configuration structures
            * @details        Index into the configuration structures
            *
            */
            #define CAN_FCC_INDEX       ((uint8)[!"num:i(CanControllerId)"!]U)
          
            /*
            * @brief          Index into the hardware platform.
            * @details        Index into the hardware platform.
            *
            */
            #define FLEXCAN_C_OFFSET    ((uint8)2U)
            
            /*
            * @brief          RxFifo Functionality enabled/disabled. Used for INTERRUPTs mapping in Can_Irq.c file.
            * @details        RxFifo Functionality enabled/disabled. Used for INTERRUPTs mapping in Can_Irq.c file.
            *
            */
            #define CAN_C_FIFO_EN       [!WS "1"!][!IF "CanControllerRxFifoEnable = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]
            
            /*
            * @brief          Error notification enabled/disabled.
            * @details        Enables/Disables the Error Controller Notification. Used for INTERRUPTs mapping in Can_Irq.c file.
            *
            */
            #define CAN_C_ERROR_NOTIFICATION_ENABLE  [!WS "1"!][!IF "CanErrorControllerNotifEn = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]
            
        [!ELSEIF "CanHwChannel = 'FlexCAN_D'"!]
            /*
            * @brief          Index into the configuration structures.
            * @details        Index into the configuration structures.
            *
            */
            #define CAN_FCD_INDEX       ((uint8)[!"num:i(CanControllerId)"!]U)
            
            /*
            * @brief          Index into the hardware platform.
            * @details        Index into the hardware platform.
            *
            */
            #define FLEXCAN_D_OFFSET    ((uint8)3U)
            
            /*
            * @brief          RxFifo Functionality enabled/disabled. Used for INTERRUPTs mapping in Can_Irq.c file.
            * @details        RxFifo Functionality enabled/disabled. Used for INTERRUPTs mapping in Can_Irq.c file.
            *
            */
            #define CAN_D_FIFO_EN       [!WS "1"!][!IF "CanControllerRxFifoEnable = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]
            
            /*
            * @brief          Error notification enabled/disabled.
            * @details        Enables/Disables the Error Controller Notification. Used for INTERRUPTs mapping in Can_Irq.c file.
            *
            */
            #define CAN_D_ERROR_NOTIFICATION_ENABLE  [!WS "1"!][!IF "CanErrorControllerNotifEn = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]
            
        [!ELSEIF "CanHwChannel = 'FlexCAN_E'"!]
            /*
            * @brief          Index into the configuration structures.
            * @details        Index into the configuration structures.
            *
            */
            #define CAN_FCE_INDEX       ((uint8)[!"num:i(CanControllerId)"!]U)
            
            /*
            * @brief          Index into the hardware platform.
            * @details        Index into the hardware platform.
            *
            */
            #define FLEXCAN_E_OFFSET    ((uint8)4U)
            
            /*
            * @brief          RxFifo Functionality enabled/disabled. Used for INTERRUPTs mapping in Can_Irq.c file.
            * @details        RxFifo Functionality enabled/disabled. Used for INTERRUPTs mapping in Can_Irq.c file.
            *
            */
            #define CAN_E_FIFO_EN       [!WS "1"!][!IF "CanControllerRxFifoEnable = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]
            
            /*
            * @brief          Error notification enabled/disabled.
            * @details        Enables/Disables the Error Controller Notification. Used for INTERRUPTs mapping in Can_Irq.c file.
            *
            */
            #define CAN_E_ERROR_NOTIFICATION_ENABLE  [!WS "1"!][!IF "CanErrorControllerNotifEn = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]
            
        [!ELSEIF "CanHwChannel = 'FlexCAN_F'"!]
            /*
            * @brief          Index into the configuration structures.
            * @details        Index into the configuration structures.
            *
            */
            #define CAN_FCF_INDEX       ((uint8)[!"num:i(CanControllerId)"!]U)
            
            /*
            * @brief          Index into the hardware platform.
            * @details        Index into the hardware platform.
            *
            */
            #define FLEXCAN_F_OFFSET    ((uint8)5U)
            
            /*
            * @brief          RxFifo Functionality enabled/disabled. Used for INTERRUPTs mapping in Can_Irq.c file.
            * @details        RxFifo Functionality enabled/disabled. Used for INTERRUPTs mapping in Can_Irq.c file.
            *
            */
            #define CAN_F_FIFO_EN       [!WS "1"!][!IF "CanControllerRxFifoEnable = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]
            
            /*
            * @brief          Error notification enabled/disabled.
            * @details        Enables/Disables the Error Controller Notification. Used for INTERRUPTs mapping in Can_Irq.c file.
            *
            */
            #define CAN_F_ERROR_NOTIFICATION_ENABLE  [!WS "1"!][!IF "CanErrorControllerNotifEn = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]
            
        [!ELSEIF "CanHwChannel = 'FlexCAN_G'"!]
            /*
            * @brief          Index into the configuration structures.
            * @details        Index into the configuration structures.
            *
            */
            #define CAN_FCG_INDEX       ((uint8)[!"num:i(CanControllerId)"!]U)
            
            /*
            * @brief          Index into the hardware platform.
            * @details        Index into the hardware platform.
            *
            */
            #define FLEXCAN_G_OFFSET    ((uint8)6U)
            
            /*
            * @brief          RxFifo Functionality enabled/disabled. Used for INTERRUPTs mapping in Can_Irq.c file.
            * @details        RxFifo Functionality enabled/disabled. Used for INTERRUPTs mapping in Can_Irq.c file.
            *
            */
            #define CAN_G_FIFO_EN       [!WS "1"!][!IF "CanControllerRxFifoEnable = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]
            
            /*
            * @brief          Error notification enabled/disabled.
            * @details        Enables/Disables the Error Controller Notification. Used for INTERRUPTs mapping in Can_Irq.c file.
            *
            */
            #define CAN_G_ERROR_NOTIFICATION_ENABLE  [!WS "1"!][!IF "CanErrorControllerNotifEn = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]
            
        [!ELSEIF "CanHwChannel = 'FlexCAN_H'"!]
            /*
            * @brief          Index into the configuration structures.
            * @details        Index into the configuration structures.
            *
            */
            #define CAN_FCH_INDEX       ((uint8)[!"num:i(CanControllerId)"!]U)
            
            /*
            * @brief          Index into the hardware platform.
            * @details        Index into the hardware platform.
            *
            */
            #define FLEXCAN_H_OFFSET    ((uint8)7U)
            /*
            * @brief          RxFifo Functionality enabled/disabled. Used for INTERRUPTs mapping in Can_Irq.c file.
            * @details        RxFifo Functionality enabled/disabled. Used for INTERRUPTs mapping in Can_Irq.c file.
            *
            */
            
            #define CAN_H_FIFO_EN       [!WS "1"!][!IF "CanControllerRxFifoEnable = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]
            
            /*
            * @brief          Error notification enabled/disabled.
            * @details        Enables/Disables the Error Controller Notification. Used for INTERRUPTs mapping in Can_Irq.c file.
            *
            */
            #define CAN_H_ERROR_NOTIFICATION_ENABLE  [!WS "1"!][!IF "CanErrorControllerNotifEn = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]
            
        [!ENDIF!]
    [!ENDLOOP!]
[!ENDSELECT!]

/*
* @brief          Optimization of INTERRUPT service code for size.
* @details        Optimization of INTERRUPT service code for size.
*
*/
#define CAN_ISROPTCODESIZE [!WS "1"!][!IF "CanGeneral/CanCodeSizeOptimization = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]

/*
* @brief          Enable Non-Autosar API for Dual-Clock support.
* @details        Enable Non-Autosar API for Dual-Clock support.
*                 This can be set to STD_ON only if it is activated from Resource file (Can.CanConfig.DualClockMode = STD_ON)
*
*/
#define CAN_DUAL_CLOCK_MODE [!WS "1"!][!IF "ecu:get('Can.CanConfig.DualClockMode')='STD_ON'"!][!IF "CanGeneral/CanEnableDualClockMode = 'true'"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!ELSE!](STD_OFF)[!ENDIF!][!CR!]

/*
* @brief          Enable Non-Autosar API for Dual-Clock support.
* @details        Enable Non-Autosar API for Dual-Clock support.
*                 This can be set to STD_ON only if it is activated from Resource file (Can.CanConfig.DualClockMode = STD_ON)
*
*/
#define  CAN_CLKSRC_CONFIG_MASK_U32 [!WS "1"!][!IF "ecu:get('Can.CanConfig.CtrlClksrcAvailable')='STD_ON'"!](0x00002000U)[!ELSE!](0x00000000U)[!ENDIF!][!CR!]

[!IF "ecu:has('Can.CanConfig.CtrlClksrcAvailable')='true'"!]
    [!IF "ecu:get('Can.CanConfig.CtrlClksrcAvailable')='STD_ON'"!]
        /* This macro is only defined if it is activated from Resource file (Can.CanConfig.DualClockMode = STD_ON) */
        #define CAN_FLEXCAN_CLKSRC_AVAIABLE
    [!ENDIF!]
[!ENDIF!]


[!IF "CanGeneral/CanAllowLoopAsCycle = 'true'"!][!// if select the TimeOut as loop cycle
/*
* @brief          Specifies the maximum time for blocking function until a timeout is detected (implement as loop cycles).
* @details        The Can module shall use the free running timer provided by the system service for timeout detection in case the hardware does not react
*                  in the expected time (hardware malfunction) to prevent endless loops.
*
*/
#if defined(ERR_IPV_FLEXCAN_0008)
    [!WS "4"!]#if (ERR_IPV_FLEXCAN_0008 == STD_ON)
    [!WS "8"!]    #define CAN_TIMEOUT_DURATION 50000U
    [!WS "4"!]#else
    [!WS "8"!]    #error: The define ERR_IPV_FLEXCAN_0008 should not be STD_OFF
    [!WS "4"!]#endif
#else
    [!WS "4"!]#define CAN_TIMEOUT_DURATION [!SELECT "CanGeneral"!][!"num:i(CanNumberOfTimeOutLoop)"!]U[!ENDSELECT!][!CR!]
#endif /* ERR_IPV_FLEXCAN_0008 */
/*
* @brief          Define timeout as loop
* @details        Define that timeout implemented as loop cycle
*
*/
    [!WS "4"!]#define CAN_TIMEOUT_AS_LOOP   (STD_ON)
[!ELSE!][!// default case, when using counter from OS
/*
* @brief          Specifies the maximum time for blocking function until a timeout is detected (implement as second).
* @details        The Can module shall use the free running timer provided by the system service for timeout detection in case the hardware does not react
*                  in the expected time (hardware malfunction) to prevent endless loops.
*
*/
    [!WS "4"!]#define CAN_TIMEOUT_DURATION [!SELECT "CanGeneral"!][!"CanTimeoutDuration * 1000000000"!]F[!ENDSELECT!][!CR!]
    
  [!SELECT "node:ref(CanGeneral/CanOsCounterRef)"!][!//
/*
* @brief          Reference to OS counter
* @details        Define the OS counter used by Candriver
*
*/
    /*
    * @violates @ref Can_Cfg_h_REF_3 Violates MISRA 2004 Required Rule 19.4, source code mentenability. 
    * @violates @ref Can_Cfg_h_REF_2 Violates MISRA 2004 Advisory Rule 19.7, Function-like macro defined.
    */
    [!WS "4"!]#define CAN_TIMEOUT_COUNTER_NAME   [!"@name"!]
/*
* @brief          Wrap macro to convert TimeOut
* @details        Define the ns time specify by 1 tick
*
*/
    /*
    * @violates @ref Can_Cfg_h_REF_3 Violates MISRA 2004 Required Rule 19.4, source code mentenability. 
    * @violates @ref Can_Cfg_h_REF_2 Violates MISRA 2004 Advisory Rule 19.7, Function-like macro defined.
    */
    [!WS "4"!]#define CAN_TIMEOUT_COUNTER_TICK2NS()   OS_TicksToNs_[!"@name"!](1U)
  [!ENDSELECT!][!//
[!ENDIF!][!//

/*
* @brief          Precompile Support.
* @details        (CAN220)VARIANT-PRE-COMPILE: Only pre-compile configuration parameters
*
*/
[!IF "IMPLEMENTATION_CONFIG_VARIANT = 'VariantPreCompile' and (variant:size()<=1)"!]
    #define CAN_PRECOMPILE_SUPPORT (STD_ON)
[!ELSE!]
    #define CAN_PRECOMPILE_SUPPORT (STD_OFF)
[!ENDIF!]

[!MACRO "CanExportDriverConfiguration"!]
[!NOCODE!][!//
[!VAR "configName" = "as:name(CanConfigSet)"!][!//
[!CODE!][!//
/* @violates @ref Can_Cfg_h_REF_3 Violates MISRA 2004 Required Rule 19.4, source code mentenability. */
#define CAN_CONF_PB \
[!ENDCODE!][!//
[!IF "var:defined('postBuildVariant')"!][!//
    [!VAR "variantIndex"="0"!][!//
    [!VAR "variantNumber"="variant:size()"!][!//
    [!LOOP "variant:all()"!][!VAR "variantIndex"="$variantIndex + 1"!][!//
    [!//
        [!CODE!][!WS4!]extern CONST(Can_ConfigType, CAN_CONST) [!"$configName"!]_[!"."!];[!IF "$variantIndex < $variantNumber"!]\[!ENDIF!][!CR!][!ENDCODE!]
    [!ENDLOOP!][!//
[!ELSE!][!//
    [!CODE!][!WS4!]extern CONST(Can_ConfigType, CAN_CONST) [!"$configName"!];[!CR!][!ENDCODE!]
[!ENDIF!][!//
[!ENDNOCODE!][!//
[!ENDMACRO!]

[!IF "((IMPLEMENTATION_CONFIG_VARIANT != 'VariantPostBuild') and (variant:size()>1)) or (IMPLEMENTATION_CONFIG_VARIANT = 'VariantPostBuild')"!]
    [!CALL "CanExportDriverConfiguration"!]
[!ENDIF!]

[!IF "node:exists(CanGeneral/CanMainFunctionBusoffPeriod)"!]
    /*
    * @brief          Periods for cyclic call of Main function
    * @details        (CAN355_Conf) CanMainFunctionBusoffPeriod - This parameter describes the period for cyclic call to Can_MainFunction_Busoff. Unit is seconds.
    *
    */
    #define CAN_MAINFUNCTION_PERIOD_BUSOFF  [!WS "1"!][!SELECT "CanGeneral"!]([!"num:i(CanMainFunctionBusoffPeriod)"!]U)[!ENDSELECT!][!CR!]
[!ENDIF!]

[!IF "(CanGeneral/CanPublicIcomSupport='true') and (ecu:get('Can.CanConfigSet.CanPretendedNetworking')='STD_ON')"!]
    /* @violates @ref Can_Cfg_h_REF_3 Violates MISRA 2004 Required Rule 19.4, source code mentenability. */
    #define CAN_PUBLIC_ICOM_SUPPORT  (STD_ON)
[!ELSE!]
    #define CAN_PUBLIC_ICOM_SUPPORT  (STD_OFF)
[!ENDIF!]

/*
* @brief          Periods for cyclic call of Main function
* @details        (ECUC_Can_00484) This parameter describes the period for cyclic call to Can_MainFunction_Read or Can_MainFunction_Write depending on the referring item. Unit is seconds. 
*                 Different poll-cycles will be configurable if more than one CanMainFunctionPeriod is configured. 
*                 In this case multiple Can_MainFunction_Read() or Can_MainFunction_Write() will be provided by the CAN Driver module..
*
*/
[!IF "num:i(count(CanGeneral/CanMainFunctionRWPeriods/*)) = 1"!]
    #define CAN_MAINFUNCTION_PERIOD         ([!"CanGeneral/CanMainFunctionRWPeriods/*[1]/CanMainFunctionPeriod"!]F)
    [!IF "$rx_pol_en = 1"!]
        #define CAN_MAINFUNCTION_PERIOD_READ    ([!"CanGeneral/CanMainFunctionRWPeriods/*[1]/CanMainFunctionPeriod"!]F)
        #define CAN_MAINFUNCTION_MULTIPLE_READ  (STD_OFF)
    [!ENDIF!]
    [!IF "$tx_pol_en = 1"!]
        #define CAN_MAINFUNCTION_PERIOD_WRITE   ([!"CanGeneral/CanMainFunctionRWPeriods/*[1]/CanMainFunctionPeriod"!]F)
        #define CAN_MAINFUNCTION_MULTIPLE_WRITE (STD_OFF)
    [!ENDIF!]
[!ELSE!]
    [!IF "$rx_pol_en = 1"!]
        #define CAN_MAINFUNCTION_MULTIPLE_READ   (STD_ON)
    [!ENDIF!]
    [!IF "$tx_pol_en = 1"!]
        #define CAN_MAINFUNCTION_MULTIPLE_WRITE   (STD_ON)
    [!ENDIF!]
    [!LOOP "CanGeneral/CanMainFunctionRWPeriods/*"!]
        #define CAN_MAINFUNCTION_PERIOD_[!"@index"!]       ([!"CanMainFunctionPeriod"!]F)
        [!IF "$rx_pol_en = 1"!]
            #define CAN_MAINFUNCTION_PERIOD_READ_[!"@index"!]       ([!"CanMainFunctionPeriod"!]F)
        [!ENDIF!]
        [!IF "$tx_pol_en = 1"!]
            #define CAN_MAINFUNCTION_PERIOD_WRITE_[!"@index"!]       ([!"CanMainFunctionPeriod"!]F)
        [!ENDIF!]
    [!ENDLOOP!]
[!ENDIF!]

/*
* @brief          Periods for cyclic call of Main function Mode
* @details        (CAN376_Conf) This parameter describes the period for cyclic call to Can_MainFunction_Mode. Unit is seconds.
*
*/
#define CAN_MAINFUNCTION_MODE_PERIOD   [!WS "1"!][!SELECT "CanGeneral"!][!"num:i(CanMainFunctionModePeriod)"!]U[!ENDSELECT!][!CR!]

[!VAR "BccSupport" = "0"!][!LOOP "CanConfigSet/CanController/*"!][!IF "CanBccSupport = 'true'"!][!VAR "BccSupport" = "1"!][!ENDIF!][!ENDLOOP!]
/*
* @brief    Defines if Backwards Compatibility Configuration (BCC) feature of CAN controller is used in the configuration.
*           If BCC feature of CAN controller is enabled, Individual Rx masking and queue feature are disabled.
*           If BCC feature of CAN controller is disabled, Individual Rx masking and queue feature are enabled.
*/
#define CAN_BCC_SUPPORT_ENABLE [!WS "1"!][!IF "$BccSupport = 1"!](STD_ON)[!ELSE!](STD_OFF)[!ENDIF!][!CR!]

[!NOCODE!]
[!VAR "Can_hardware_ob_id" = "0"!]
[!LOOP "CanConfigSet/CanHardwareObject/*"!]
    [!IF "$Can_hardware_ob_id < CanObjectId"!]
        [!VAR "Can_hardware_ob_id" = "CanObjectId"!]
    [!ENDIF!]
[!ENDLOOP!]
[!ENDNOCODE!]
/*
@brief    Macro used to define the maximum of Can object IDs configured  .
*/
#define CAN_MAX_OBJECT_ID ((uint32)[!"num:i($Can_hardware_ob_id + 1)"!]U)

#define CAN_CONTROLLER_REFERENCE_COUNTER   [!WS "1"!][!"(num:i(ecu:get('Can.CanConfigSet.CanController')))"!][!CR!]

/*==================================================================================================
*                                      DEFINES AND MACROS
==================================================================================================*/

[!VAR "Can_Controller_counter" = "0"!]
[!VAR "Can_Controller_Reference" = "(num:i(ecu:get('Can.CanConfigSet.CanController'))-1)"!]
[!FOR "Can_Controller_counter" = "0" TO "num:i($Can_Controller_Reference)"!]
    [!VAR "Can_Mb_counter" = "text:split(ecu:get('Can.CanConfigSet.CanController.NoMB'), ',')[position()-1 = $Can_Controller_counter]"!]
    [!IF "($Can_Mb_counter) <=32"!]
       /* @violates @ref Can_Cfg_h_REF_3 Violates MISRA 2004 Required Rule 19.4, source code mentenability. */
        #define CAN_MB_CONTROLLER_[!"num:i($Can_Controller_counter+1)"!]     32U
    [!ELSEIF "(($Can_Mb_counter > 32) and ($Can_Mb_counter <=64))"!]
        /* @violates @ref Can_Cfg_h_REF_3 Violates MISRA 2004 Required Rule 19.4, source code mentenability. */     
        #define CAN_MB_CONTROLLER_[!"num:i($Can_Controller_counter+1)"!]     64U
    [!ELSEIF "(($Can_Mb_counter > 64) and ($Can_Mb_counter <=96))"!]
        /* @violates @ref Can_Cfg_h_REF_3 Violates MISRA 2004 Required Rule 19.4, source code mentenability. */
        #define CAN_MB_CONTROLLER_[!"num:i($Can_Controller_counter+1)"!]     96U
    [!ENDIF!]    
[!ENDFOR!]

/*==================================================================================================
*                                             ENUMS
==================================================================================================*/

/*==================================================================================================
*                                STRUCTURES AND OTHER TYPEDEFS
==================================================================================================*/

/*==================================================================================================
*                                GLOBAL VARIABLE DECLARATIONS
==================================================================================================*/

/*==================================================================================================
*                                    FUNCTION PROTOTYPES
==================================================================================================*/
[!IF "node:exists(CanGeneral/CanLPduReceiveCalloutFunction)"!]
    [!SELECT "CanGeneral"!]
        [!IF "(normalize-space(CanLPduReceiveCalloutFunction) != 'NULL_PTR')"!]
            /*
            @brief    This inclusion shall be made here, after the definition of other defines  which are used by the included file.
            */
            /** @violates @ref Can_Cfg_h_REF_2 Violates MISRA 2004 Advisory Rule 19.7, Function-like macro defined.*/
            #define CanLPduReceiveCalloutFunction     ([!"normalize-space(CanLPduReceiveCalloutFunction)"!])
        [!ENDIF!]
    [!ENDSELECT!]
[!ENDIF!]

[!ENDINDENT!]

#ifdef __cplusplus
}
#endif

#endif /* _CAN_CFG_H_ */

/** @} */
